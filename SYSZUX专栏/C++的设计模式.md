##  **背景**

我们在做项目时，项目各函数、模块之间往往得有一种好的组织方式，才能让项目更好的开发、维护、扩展、自检。幸运的是，通过前人的各种花式实践，以及某些有心人的总结提炼，我们能轻松说出这些组织方式——称之为编程的设计模式。

因为Gemfield在项目中用到的语言主要是C++，和Python、Object-C等都是面向对象的编程语言，因此本文主要说的是OOP中的C++设计模式。

设计模式主要有这几类：

  1. 创建对象的：既然是面向对象的编程，那当然首先得有对象啊； 
  2. 类和对象之间的组合方式； 
  3. 对象之间如何通信的； 
  4. 模板大法好。 

##  **创建对象的设计模式**

这种设计模式的目的就是用来创建各种对象，不同于直接实例化一个具体的对象，通过这类设计模式，我们可以更优雅的根据外部条件创建出所需的对象。

主要有这5种：

  1. 工厂方法 (Factory Method pattern) 
  2. 建造者模式 (Builder Pattern) 
  3. 抽象工厂 (Abstract Factory) 
  4. 原型模式 (Prototype pattern) 
  5. 单例模式 (Singleton pattern) 

**工厂方法**
就是在创建对象时使用了继承体系中多态的最简单要义。举个例子，人要生产好的产品（这个产品就是要创建的对象），那么人的继承体系中（简单起见，只有1层继承）：

    
    
    //基类——人：生产出好的产品
    学生：生产出好的学习作品；
    码农：生产出好的代码；
    农民：生产出好的水果；
    人大代表：生产出好的议案；
    政协委员：生产出好的提案；
    ......

**建造者模式，**
就是将构造对象的过程拆分成好过个步骤，每一个步骤都是独立的，是可以响应外部条件的，是可更换的。比如，码农生产出好的代码这个对象，步骤可以分为：

    
    
    //生产出好的代码
    1，做1个好的需求评审；
    2，做1个好的设计和设计评审；
    3，做1个好的代码和代码评审；
    4，做1个好的UT和UT评审

每一步是独立的，是可更换的，是可以根据外部条件做出变化的，最后生产出好的代码——也就是构建出最终的对象。你也可以看到，每一步都可以使用 **工厂方法**
的设计模式。

**抽象工厂** ，如果说工厂方法是通过继承，那么抽象工厂就是 **偏重组合** ；这个组合有两重含义：

  1. 抽象工厂类本身的各个方法是相关的，组合在一起； 
  2. 抽象工厂类是组合嵌入到别的类（称之为client类吧）中的，也就是说抽象工厂类的实例会成为client类的一个成员，由client来负责调用抽象工厂来创建对象。 

比如代工厂是个抽象工厂类，可以：

    
    
    //代工厂，本身的方法是相关的，有联系的
    生产屏幕；
    生产电池；
    生产主板；

抽象工厂类的子类有富士康、广达、比亚迪等这些子类；这些子类的实例分别嵌入到苹果、华为、小米这些Client类中。比如华为要想创建手机这个对象，通过其嵌入的代工厂（抽象工厂，假设今年这个实例指向富士康）来分别生产屏幕电池主板，最后生产出手机。

**原型模式** ，就是通过已有的对象 **copy** 出新的对象；比如：

  1. 程序员通过github已有的代码复制出自身项目的代码； 
  2. 智能手表厂商通过复制apple watch来创建出自己品牌的手表； 

**单例模式，**
就是确保一个类在程序生命周期里最多只有一个实例；比如“一个中国”在“世界”没有毁灭前就是个单例模式；单例对象的创建可通过条件判断+工厂方法；也可以通过在函数中使用static语义来实现。

##  **类和对象之间的组合方式**

这里说的就是类或者对象之间如何组合(如何搭积木)，用来提供一致的接口、分离接口与实现、以不变应万变、节省内存空间、隐藏实现等。这个领域常见的设计模式有：

  1. 适配器(Adapter pattern) 
  2. 桥接(Bridge pattern) 
  3. 组合(Composite pattern) 
  4. 装饰(Decorator pattern) 
  5. 门面模式(Façade pattern) 
  6. 享元(Flyweight pattern) 
  7. 代理(Proxy pattern) 

**桥接模式** ，意图是让接口和实现分离，类似于模板模式和策略模式的组合。举个例子：  

    
    
    //Gemfield
                       ----------------国家---------------
                      /                                   \
             资本主义国家                                 社会主义国家
            /              \                              /            \
    计划经济资本主义国家 市场经济资本主义国家   计划经济社会主义国家 市场经济社会主义国家

使用桥接模式重构为

    
    
            ----------------国家---------------                          经济工具
           /                                   \                        /        \
    资本主义国家(经济工具)         社会主义国家(经济工具)          市场经济     计划经济

这样，具体的实现就被分离开了。

**组合模式** ，就是一个类的接口行为和由其组合而成的类的接口行为一样，类似分型一样，Client调用它们的行为都是一致的。比如：

    
    
    县政府提供治安、财税、统计、应急服务等接口；
    
    //市政府这个类由不同的县政府组成；
    市政府提供治安、财税、统计、应急服务等接口；
    
    //省政府这个类由不同的市政府组成；
    省政府提供治安、财税、统计、应急服务等接口；
    
    这三种类对外提供的接口行为一致。

**适配器模式** ，Adapter pattern，又叫Wrapper
pattern，这个就很容易理解了。比如显示器对外提供HDMI接口，但是Client类（比如CivilNet的macbook air
2018款）需要使用type-c接口，那么就在显示器这个类上覆盖个wrapper，wrapper一边调用显示器的hdmi接口，另外一边对外提供type-
c接口。现实世界中，这个adapter类/Wrapper类就是type-
c转HDMI数据线。这里的重点是，adapter类和被adapter的类有接口的映射关系，接口的名字不一样但功能一样。比如上面的例子，接口的名字分别是type-
c和hdmi，但都是为了显示的功能。

**装饰模式**
，也叫修饰模式，是动态的往一个对象上添加行为，而又不影响该类其它对象的模式（这就是和通过继承、组合等有所区别的关键点，继承、组合等是定义了新的类，而不是改变已有对象的行为）。一般是通过把一个对象实例传给装饰类的构造函数来动态添加的。比如，同一个型号的手机就是同一个类的多个实例，而手机壳就是装饰类，把手机对象传给装饰类的构造函数，手机对象就有了不同的行为，比如有的手机对象看着更漂亮，有的手机对象更加防水（像Gemfield的潜水手机壳），有的手机对象更加耐摔。

**门面模式**
，这个也很简单，和普通的函数封装差不多，把多个子系统中的一组接口封装在门面类/外观类的一个接口里（繁杂的大量的代码变成了简单的少量代码），对客户类提供这个统一的门面类/外观类的接口，过于简单就不解释了。

**享元模式，** Flyweight pattern，就是组合模式+单例模式，节省内存空间。比如雕版印刷术通过享元模式就重构为了活字印刷术。

**代理模式，** 主要目的是隐藏实现；比如代理人战争，proxy war（通过proxy
pattern重构的战争模式）。比方说越战就是美苏之间的代理人战争，没有这个代理模式的重构，战争那可能就变成核战了——比如古巴导弹危机。

##  **对象间的通信**

  1. 职责链(Chain-of-responsibility pattern) 
  2. 命令(Command pattern) 
  3. 解释器(Interpreter pattern) 
  4. 迭代器(Iterator pattern) 
  5. 中介者(Mediator pattern) 
  6. 备忘录(Memento pattern) 
  7. 观察者(Observer pattern) 
  8. 状态机(State pattern) 
  9. 策略(Strategy pattern) 
  10. 模板方法(Template method pattern) 
  11. 访问者模式(Visitor pattern) 

**职责链模式，**
这个模式的关键是两点，一是输入信息被封装和抽象，二是有多个对象要有接口先后响应和处理这个请求。比如大boss的讲话精神被封装为一个学习文件，同一个输入，从常委、省委、市委、县委要先后学习和响应。政令畅通就有赖于这种设计模式。

**命令模式，** 就是把动作从以前的函数封装重构为对象封装，是OOP的基本要义了。

**解释器模式，** 和组合模式类似，只是这里更强调行为，用于词法分析。

**迭代器模式，** 对集合里的所有元素提供同一种操作，因此容器的方法中大量包含迭代器的使用。

**中介者模式，**
比如你有一些类的不同对象实例Ｘ，Ｙ，Ｚ等，这些实例之间要通信必须要互相包含对方的引用吗？不需要，你通过设立一个中介类M，每个要通信的实例都共享一个指向Ｍ实例的引用，通过Ｍ可以实现ＸＹＺ之间的通信。听名字就能和现实社会中的房屋中介关联起来，买卖双方彼此不认识对方没有对方的手机号，却共享同一个中介实例的引用，通过中介机构来进行通信。

**备忘录模式，** 通过将对象的状态保存在对象之外，可以有机会重置该对象的状态。

**观察者模式，**
比如有个类Syszux，有很多其它的类通过注册到Syszux这里来实现对Syszux的观察，Syszux实例有什么新的消息或状态，就挨个通知注册到这里的对象。比如在餐厅排号吃美食，别的食客和你把各自的信息注册到前台，等有了空位置餐厅就通知出来。

**状态机模式，**
context类是对外的接口；状态用类来封装，每种状态用状态基类的子类封装，并实现该状态相关的方法；context类中有对状态基类的引用；要改变状态——就改变context中基类引用（指针）指向不同的状态实例。

**策略模式** ，就是OOP多态的要义，没啥好说的。

**模板方法，** 基类定义接口（没有实现）以及这些接口的调用流程；子类重新实现这些接口而不用关心调用流程；也就是说，框架级别的操作在基类已经确定了。

**访问者模式，** 当添加一个新的方法时，不需要改动类的继承体系中的每个类。

  

##  **模板大法好**

